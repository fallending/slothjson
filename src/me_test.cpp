////////////////////////////////////////////////////////////////////////////////
// NOTE : Generated by slothjson. It is NOT supposed to modify this file.
////////////////////////////////////////////////////////////////////////////////
#include "me_test.h"

namespace slothjson {

metest_object_t::metest_object_t()
{
    isStarted = false;
    __skip_isStarted = false;
    __json_has_isStarted = false;

    mak = 0;
    __skip_mak = false;
    __json_has_mak = false;

    fin = 0;
    __skip_fin = false;
    __json_has_fin = false;

    th = 0;
    __skip_th = false;
    __json_has_th = false;

    sh = 0;
    __skip_sh = false;
    __json_has_sh = false;

    len = 0;
    __skip_len = false;
    __json_has_len = false;

    count = 0;
    __skip_count = false;
    __json_has_count = false;

    length = 0;
    __skip_length = false;
    __json_has_length = false;

    age = 0;
    __skip_age = false;
    __json_has_age = false;

    amountd = 0.0;
    __skip_amountd = false;
    __json_has_amountd = false;

    amount = 0.0;
    __skip_amount = false;
    __json_has_amount = false;

    __skip_str = false;
    __json_has_str = false;

    __skip_vec = false;
    __json_has_vec = false;

    __skip_dict = false;
    __json_has_dict = false;
}

metest_object_t& metest_object_t::operator=(const metest_object_t& obj_val)
{
    this->isStarted = obj_val.isStarted;
    this->mak = obj_val.mak;
    this->fin = obj_val.fin;
    this->th = obj_val.th;
    this->sh = obj_val.sh;
    this->len = obj_val.len;
    this->count = obj_val.count;
    this->length = obj_val.length;
    this->age = obj_val.age;
    this->amountd = obj_val.amountd;
    this->amount = obj_val.amount;
    this->str = obj_val.str;
    this->vec = obj_val.vec;
    this->dict = obj_val.dict;
    return *this;
}

bool metest_object_t::operator==(const metest_object_t& obj_val) const
{
    if (!(this->isStarted == obj_val.isStarted)) return false;
    if (!(this->mak == obj_val.mak)) return false;
    if (!(this->fin == obj_val.fin)) return false;
    if (!(this->th == obj_val.th)) return false;
    if (!(this->sh == obj_val.sh)) return false;
    if (!(this->len == obj_val.len)) return false;
    if (!(this->count == obj_val.count)) return false;
    if (!(this->length == obj_val.length)) return false;
    if (!(this->age == obj_val.age)) return false;
    if (!(this->amountd == obj_val.amountd)) return false;
    if (!(this->amount == obj_val.amount)) return false;
    if (!(this->str == obj_val.str)) return false;
    if (!(this->vec == obj_val.vec)) return false;
    if (!(this->dict == obj_val.dict)) return false;
    return true;
}

bool metest_object_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
{
    do
    {
        json_val.SetObject();
        if (!__skip_isStarted && !encode_field(isStarted, "isStarted", alloc, json_val)) break;
        if (!__skip_mak && !encode_field(mak, "mak", alloc, json_val)) break;
        if (!__skip_fin && !encode_field(fin, "fin", alloc, json_val)) break;
        if (!__skip_th && !encode_field(th, "th", alloc, json_val)) break;
        if (!__skip_sh && !encode_field(sh, "sh", alloc, json_val)) break;
        if (!__skip_len && !encode_field(len, "len", alloc, json_val)) break;
        if (!__skip_count && !encode_field(count, "count", alloc, json_val)) break;
        if (!__skip_length && !encode_field(length, "length", alloc, json_val)) break;
        if (!__skip_age && !encode_field(age, "age", alloc, json_val)) break;
        if (!__skip_amountd && !encode_field(amountd, "amountd", alloc, json_val)) break;
        if (!__skip_amount && !encode_field(amount, "amount", alloc, json_val)) break;
        if (!__skip_str && !encode_field(str, "str", alloc, json_val)) break;
        if (!__skip_vec && !encode_field(vec, "vec", alloc, json_val)) break;
        if (!__skip_dict && !encode_field(dict, "dict", alloc, json_val)) break;

        return true;
    } while (0);

    return false;
}

bool metest_object_t::decode(const rapidjson::Value& json_val)
{
    do
    {
        if (!decode_field(json_val, "isStarted", isStarted, __json_has_isStarted)) break;
        if (!decode_field(json_val, "mak", mak, __json_has_mak)) break;
        if (!decode_field(json_val, "fin", fin, __json_has_fin)) break;
        if (!decode_field(json_val, "th", th, __json_has_th)) break;
        if (!decode_field(json_val, "sh", sh, __json_has_sh)) break;
        if (!decode_field(json_val, "len", len, __json_has_len)) break;
        if (!decode_field(json_val, "count", count, __json_has_count)) break;
        if (!decode_field(json_val, "length", length, __json_has_length)) break;
        if (!decode_field(json_val, "age", age, __json_has_age)) break;
        if (!decode_field(json_val, "amountd", amountd, __json_has_amountd)) break;
        if (!decode_field(json_val, "amount", amount, __json_has_amount)) break;
        if (!decode_field(json_val, "str", str, __json_has_str)) break;
        if (!decode_field(json_val, "vec", vec, __json_has_vec)) break;
        if (!decode_field(json_val, "dict", dict, __json_has_dict)) break;

        return true;
    } while (0);

    return false;
}

bool encode(const metest_object_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return obj_val.encode(alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, metest_object_t& obj_val)
{
    return obj_val.decode(json_val);
}

} // namespace slothjson